package dw.memo;

public class note240425 {
    // Spring Security = 스프링의 하위 프레임워크
    // 강력한 기능, 성능, 덩치(스프링과는 또다른 느낌)
    // 자유가 거의 없음, 설치하고 그대로만 써야되는?
    // 뒷쪽에서 돌아가는게 대다수

    // 인증 / 인가
    // 인증 : 로그인하는거
    // 인가 : 권한(ex. Admin, User, Teacher로 구분하는거)
    // → 권한 많이 만드면 마무리할때 힘들다고함

    // username , password ← 인증 / ROLE_ ← 권한
    // → 최소한 이 3개는 꼭 외워야함

    // 인증방식
    //  1. 세션 - 가상의 통로같은 역할 (ID - 일반적으로 아는 ID와는 다른듯?)
    //      → 유저가 로그아웃하거나, 만료시간 지나면 소멸
    //      → 해킹의 문제가 있어 점점 세션시간이 짧아지고 복잡한 값을 적으라고 함
    //      → 쿠키에다 써놓음(세션 ID 저장(도메인 + 세션ID))
    //      → 세션ID : 요청하는 모든 패킷(헤더에 존재) 포함
    //      → 전통적인 방식
    //      → 요즘에도 기능은 하지만 최근에는 거의 안쓴다고함
    //      → 구조적으로 만료시간 극단적으로 줄이는게 불가능 

    //  2. 토큰(JWT : Jason Web Token) - 
    //      → 인증되면 인증서버에서 토큰을 만들게됨
    //      → 서버에서 2가지 토큰(엑세스토큰, 리프레시토큰)를 유저에게 부여
    //      → 유저는 엑세스토큰을 계속 서버에 보냄
    //      → 토큰자체에 만료시간이 존재(토큰 안에는 username, 만료시간만 있음)
    //      → 토큰은 라이프타임이 굉장히 짧음(3~5분정도?)
    //      → 엑세스토큰이 만료되면 자동으로 리프레시 토큰을 서버에 보내서 다시 엑세스 토큰을 갱신함
    //      → 유저가 귀찮을 일이 없음
    //      → 장점 1 : 유지관리비가 저렴(세션방식때에 별도로 사용했던 서버를 사용할 필요없음)
    //      → 헤더 / payload(전체가 암호화되어있음) / signiture 3개의 부분으로 나뉘는데
    //          헤더에는 JWT와 암호화기술(어떤 기술인지 적혀있음)을
    //          payload에는 username, ROLE, 만료시간을
    //          시그니쳐에는 헤더와 payload와 key 값이 포함된 것이 암호화되어있음
    //          규칙을 풀려면 key가 필요 → 서버에만 존재(실질적으로 해킹 불가능하니 암호화기술을 참고하여 key값을 알아내려고 한다고함)
    //          시그니처에 있는 값은 다른방식으로 암호화되어있기에 만료시간이 지나면 다른값이 되버림
    //      → 장점 2 : 이중보안으로 ???(대충 세션보다 낫다는 의미)
    //      → 장점 3 : 일일히 재로그인 할 필요가 없음
    //      → 단점 : 코드가 좀...

    //  3. OAuth2 - 로그인 인증을 대행사이트를 이용하여 진행하는것(가입없이 ~로 로그인 이런거 뜨는방식 말함)
    //      → 인증서버까지 사용할 필요 X(매우간편)

    // SecurityConfig - 스프링시큐리티 환경설정파일(매우중요!!)
    // → 업데이트가 자주 일어나서 선생님이 만들어주신 파일이 오류투성이가 될 수 있음
    // → 그때는 따로 변경사항 공부하여 그에 맞게 변경해줘야됨

    // .anyRequest().authenticated() - 어떤것이라도 승인해주겠다
    // → 이거 있어서 위에 허용할 대상 입력함 new AntPathRequestMatcher("/user/login") 이런거
    // → 필수로 열어줘야 될 대상 : login, signup, static login
    // .permitAll() → 대상 전부 허용
    // 개발중에는 최상단 주소 /** 해주면 그 아래 전부 허용임
    
    // form.longinPage() - 정적 로그인 페이지가 존재하는 경우에만 사용(기본제공 로그인페이지 말고 이걸로 쓴다는의미)
    // successUrl() - 로그인 성공시 대당 주소로 넘어간다는 의미
    // SessionManagemant~.ALWAYS - 세션 안쓰면 필요없는 것(프로젝트때는 안쓸것)
    // CSRF(Cross Site Request Forgery) - 디도스같은?, 다른사이트에서 특정 사이트를 접속하는 것
    // → ex) 가짜은행사이트(거의 똑같은데 입력하는 순간 큰일나는 그런거)
    // → 과거에 유행했던 해킹방법
    // 즉, 우리가 만든 웹 사이트가 아닌 다른 사이트에서 서버로 요청이 오면 차단하는것
    // 그럼에도 .csrf()가 disable되있는 이유는 더 좋은 거 사용하기 때문에 막아두는것임
    // .authentication~ : 권한오류?
    // .access~ : 인증실패
    
    // bcrypt(기억!! 암호화할때 사용할것) : 해시함수
    // → 인코딩보다 더 강력함
    // → 역으로 원상복귀가 안됨(7대 난제와 비슷한 수준)
    //

    // 서블렛? - 아주작은 애플리케이션(Java로 만든 것)

    
    // Security context는 단 한개만 존재함
    
    // principal authorities = 유저 권한

    // Dao = Database association object
    
    // resource - static : 정적 페이지를 모아놓는 디렉토리
    // → 누가보던 항상 같은 화면(기본적 정의) + @
    // 동적 페이지 : 상황, 상태에 따라 다른화면나옴
    // → 변수가 담겨있어 값이 변화하는 것에 따른 화면을 보여주는것
    
    // frefix(@RequestMapping) 사용시 하위 Mapping 주소 적을때 시작부분에 / 붙이지 말 것
    
    // SecurityConfig 내용 꼭 기억할 것









}


